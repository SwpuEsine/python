map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，
并把结果作为新的Iterator返回。

reduce() 函数接收一个函数  一个可迭代对象 

但是这个函数必须有两个参数

filter() 函数接收两个参数   一个函数  一个可迭代对象  会把函数作用于每个可迭代对象中

如果为true 则保存  否则丢弃

这三个函数的返回值是一个惰性序列 iterator  因此要用List 显式的进行转换



/*************************************迭代器*************************************/

在Python中，for循环可以用于Python中的任何类型，包括列表、元祖等等，实际上，for循环可用于任何“可迭代对象”，这其实就是迭代器

迭代器是一个实现了迭代器协议的对象，Python中的迭代器协议就是有next方法的对象会前进到下一结果，
而在一系列结果的末尾是，则会引发StopIteration

使用迭代器一个显而易见的好处就是：每次只从对象中读取一条数据，不会造成内存的过大开销。

比如要逐行读取一个文件的内容，利用readlines()方法，我们可以这么写：

for line in open("test.txt").readlines():
    print line
	
	
for line in open("test.txt"):   #use file iterators
    print line
	
	
当一个函数中有了yield的时候  就是生成器   一个有yield的函数   是一个可迭代的函数

iterator函数


>>> def g(n):
...     for i in range(n):
...             yield i **2
...
>>> for i in g(5):
...     print i,":",
...
0 : 1 : 4 : 9 : 16 :



/******************************************生成器*******************************************/

Generators(生成器)也是可迭代的，但是你每次只能迭代它们一次，
因为不是所有的迭代器都被一直存储在内存中的，他们临时产生这些值：
>>> mygenerator = (x*x for x in range(3))
>>> for i in mygenerator:
...    print(i)


生成器几乎和迭代器是相同的，除了符号[]变为()。但是你无法用两次，因为他们只生成一次：
他们生成0然后丢弃，继续统计1，接着是4，一个接着一个。

/******************************************排序*********************************************/

函数高阶函数  sorted()函数也是一个高阶函数，它还可以接收一个key函数来实现自定义的排序，例如按绝对值大小排序：



/*************************************python中lambda  兰姆达表达式*******************************8/

list(map(lambda x:x*x,[1,2,3]))


dict.get(key, default=None)


